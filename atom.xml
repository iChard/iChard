<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://ichard.github.io/iChard/</id>
    <title>Gridea</title>
    <updated>2019-09-16T08:12:08.081Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://ichard.github.io/iChard/"/>
    <link rel="self" href="https://ichard.github.io/iChard//atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://ichard.github.io/iChard//images/avatar.png</logo>
    <icon>https://ichard.github.io/iChard//favicon.ico</icon>
    <rights>All rights reserved 2019, Gridea</rights>
    <entry>
        <title type="html"><![CDATA[hash/chunkhash/contenthash区别]]></title>
        <id>https://ichard.github.io/iChard//post/hashchunkhashcontenthash-qu-bie</id>
        <link href="https://ichard.github.io/iChard//post/hashchunkhashcontenthash-qu-bie">
        </link>
        <updated>2019-09-16T07:03:01.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/ihardcoder/p/5623411.html">参考链接</a></p>
<h2 id="定义">定义</h2>
<p><strong>首先看一下官方的定义</strong></p>
<ol>
<li>
<p><code>hash</code>: 代表的是根据*<code>compilation</code>*过程计算的<code>hash</code>，其中compilation代表整个webpack的compiler编译过程，这些过程包括(打包文件内容、webpack配置等)</p>
</li>
<li>
<p><code>chunkhash</code>: 代表的是根据<code>chunk</code>内容计算的<code>hash</code>，chunk在webpack中表示最终打包的输出文件</p>
</li>
<li>
<p><code>contenthash</code>:指根据<code>文件内容</code>计算得来的<code>hash</code></p>
</li>
</ol>
<h2 id="示例">示例</h2>
<p><strong>后面的示例都会根据下面的项目结构和webpack配置进行修改和演示</strong></p>
<ol>
<li>代码结构</li>
</ol>
<pre><code>--demo4//项目入口文件
	--index.js
	--style.css
--package.json
--dist-demo4//打包目录
--webpack.config.js
</code></pre>
<ol start="2">
<li>webpack.config.js</li>
</ol>
<pre><code class="language-js">const path = require('path')
const CleanWebpackPlugin = require('clean-webpack-plugin')
const MiniCssExtractPlugin = require('mini-css-extract-plugin');// 用于抽离css文件，暂时可不管

module.exports = {
    entry: {
        index1: './demo4/index.js',
    },
    output: {
        filename: '[name].[hash:8].js',
        path: path.resolve(__dirname, 'dist-demo4')
    },
  	module: {
        rules: [
            {test: /\.css$/,
             use: [{loader: MiniCssExtractPlugin.loader},'css-loader']}// 用于抽离css文件，暂时可不管
        ]
    },
   plugins: [
        new CleanWebpackPlugin(),
     		new MiniCssExtractPlugin({
            filename: '[name].[contenthash:8].css',
	          chunkFilename: '[id].css'
        }),
    ]
}
</code></pre>
<ol start="3">
<li>index.js</li>
</ol>
<pre><code class="language-js">console.log('chunk')
</code></pre>
<ol start="4">
<li>style.css</li>
</ol>
<pre><code class="language-css">a {font-size: 12px;}
</code></pre>
<h2 id="hash">hash</h2>
<p>根据上述定义，当在整个编译过程中一切都没改变时，所已算的hash是不会变的；但是代码变动或者webpack配置变动都会引起hash的计算变动</p>
<h3 id="代码改变">代码改变</h3>
<ol>
<li>首先我们执行编译<code>npm start</code>记录第一次计算的hash，得到hash值为<code>4b5d33fd</code></li>
</ol>
<pre><code class="language-shell">              Asset      Size  Chunks             Chunk Names
 index1.4b5d33fd.js  1.02 KiB       0  [emitted]  index1
</code></pre>
<ol start="2">
<li>修改<code>index.js</code>代码并执行npm start查看新的hash值<code>d768a965</code></li>
</ol>
<pre><code class="language-js">// index.js
console.log('chunk changed')
// 编译
index1.d768a965.js  1.01 KiB       0  [emitted]  index1
</code></pre>
<h3 id="配置更改">配置更改</h3>
<ol>
<li>首先将webpack.config.js的配置做一点修改，编译之后得到hash值<code>e43fce73</code></li>
</ol>
<pre><code class="language-js">// webpack.config.js:修改插件MiniCssExtractPlugin.chunkFilename
chunkFilename: '[name].[id].css'//增加了[name].
//编译
index1.e43fce73.js  1.01 KiB       0  [emitted]  index1
</code></pre>
<p><strong>注意： 配置更改必须要影响到整个编译过程其hash才会变动，单纯的在webpack.config.js中修改一些无意义代码的话hash是不会变动的</strong></p>
<ol start="2">
<li>简单修改webpack.config.js并执行编译得到hash仍为<code>e43fce73</code></li>
</ol>
<pre><code class="language-js">// 在webpack.config.js中增加一个console
console.log('the compiler will not change')
// 编译
 index1.e43fce73.js  1.01 KiB       0  [emitted]  index1
</code></pre>
<h2 id="chunkhash">chunkhash</h2>
<p>根据定义得知chunkhash是根据打包的整个chunk内容计算hash，当整个chunk引入任意一个文件发生变动时，编译的chunk都会修改；</p>
<ol>
<li>首先修改对应的webpack.config.js配置文件,将output的filename修改为<code>filename: '[name].[chunkhash:8].js',*</code>；然后在index.js中引入style.css</li>
</ol>
<pre><code class="language-js">// wwebpack.config.js修改
output: {
        filename: '[name].[chunkhash:8].js',
        path: path.resolve(__dirname, 'dist-demo4'),
}
// index.js
import './style.css'

console.log('chunk changed')   
</code></pre>
<ol start="2">
<li>编译打包得到第一次参考的chunkhash为<code>87319c9f</code></li>
</ol>
<pre><code class="language-sh">index1.87319c9f.css  43 bytes       0  [emitted]  index1
 index1.87319c9f.js  1.01 KiB       0  [emitted]  index1
</code></pre>
<ol start="3">
<li>修改<code>index.js</code>的到chunkhash为：  <code>266332c3</code></li>
</ol>
<pre><code class="language-she">index1.266332c3.css  21 bytes       0  [emitted]  index1
 index1.266332c3.js  1.01 KiB       0  [emitted]  index1
</code></pre>
<ol start="4">
<li>修改<code>style.css</code>为<code>a {font-size: 14px;}</code>得到chunkhash为：<code>e84f56fd</code></li>
</ol>
<pre><code class="language-sh">index1.e84f56fd.css  21 bytes       0  [emitted]  index1
 index1.e84f56fd.js  1.01 KiB       0  [emitted]  index1
</code></pre>
<p><strong>注意到上面打包的js和css的chunkhash值都是一样的，但是这里我们的css文件已经通过插件<code>mini-css-extract-plugin</code>从chunk中抽离出来了，因此我们可能希望打包的css拥有和chunk不一样的hash；此时我们就可以使用contenthash了</strong></p>
<h2 id="contenthash">contenthash</h2>
<p>根据定义contenthash时根据文件内容计算具体的hash值</p>
<p>因此当我们使用<code>mini-css-extract-plugin</code>将css抽离成一个单独文件时，可将该css的名称配置为<code>filename: '[name].[contenthash:8].css'</code>，同时也将output打包出的chunk配置成contenthash，<strong>这样当css内容变动时，chunk的contenthash不会变动；chunk中非css文件的修改也不会影响到css的contenthash计算</strong></p>
<h3 id="webpackconfigjs修改">webpack.config.js修改</h3>
<pre><code class="language-js">output: {
  	filename: '[name].[contenthash:8].js',
    path: path.resolve(__dirname, 'dist-demo4'),
},
plugins: [
  	new CleanWebpackPlugin(),
  	new MiniCssExtractPlugin({
    		filename: '[name].[contenthash:8].css',
    		chunkFilename: '[name].[id].css'
  	}),
]
</code></pre>
<ol>
<li>首先拿到第一次编译的contenthash值，<code>js: ae51424c</code>  <code>css: d8b9fd9f</code></li>
</ol>
<pre><code class="language-sh"> index1.ae51424c.js  1.01 KiB       0  [emitted]  index1
index1.d8b9fd9f.css  21 bytes       0  [emitted]  index1
</code></pre>
<ol start="2">
<li>修改index.js不修改style.css得到，<code>js: 7a941304</code>  <code>css: d8b9fd9f</code>;可以看到css的contenthash并没有变动</li>
</ol>
<pre><code class="language-sh"> index1.7a941304.js  1.01 KiB       0  [emitted]  index1
index1.d8b9fd9f.css  21 bytes       0  [emitted]  index1
</code></pre>
<ol start="3">
<li>修改style.css不修改index.js得到，<code>js: 7a941304</code>  <code>css: 00583d11</code>;可以看到此时js的contenthash没有变动，只有css文件的contenthash变动</li>
</ol>
<pre><code class="language-sh">index1.00583d11.css  21 bytes       0  [emitted]  index1
 index1.7a941304.js  1.01 KiB       0  [emitted]  index1
</code></pre>
<p>webpack官方文档</p>
<h2 id="应用场景">应用场景</h2>
<p>当你的网站需要考虑长效缓存，可以使用不同的hash</p>
<ol>
<li>当没有将css从chunk中抽离时直接<code>使用chunkhash</code></li>
<li>当使用<code>mini-css-extract-plugin</code>插件抽离css时<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>,可将chunk和css块都使用<code>contenthash</code>替换达到互不影响的作用</li>
<li>不要使用hash，这可能因为webpack的修改导致hash值变动而使缓存失效</li>
</ol>
<p>关于hash的使用场景，可考虑将其作为版本控制；如将webpack.config.js的output.path更改为<code>path.resolve(__dirname, 'dist-demo4', '[hash:6]')</code>，这样就会将每次编译的版本保存为一个新目录；其他的场景暂时也想不到，欢迎大家分享:cowboy_hat_face:</p>
<h2 id="脚注">脚注</h2>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>webpack官方文档推荐使用extract-text-webpack-plugin抽离css，但是实际上在webpack4中因为部分api的废除导致extract-text-webpack-plugin不再支持了，可以参考该插件的github介绍 <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hello Gridea]]></title>
        <id>https://ichard.github.io/iChard//post/hello-gridea</id>
        <link href="https://ichard.github.io/iChard//post/hello-gridea">
        </link>
        <updated>2018-12-11T16:00:00.000Z</updated>
        <summary type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
]]></summary>
        <content type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
<!-- more -->
<p><a href="https://github.com/getgridea/gridea">Github</a><br>
<a href="http://hvenotes.fehey.com/">Gridea 主页</a><br>
<a href="http://fehey.com/">示例网站</a></p>
<h2 id="特性">特性👇</h2>
<p>📝  你可以使用最酷的 <strong>Markdown</strong> 语法，进行快速创作</p>
<p>🌉  你可以给文章配上精美的封面图和在文章任意位置插入图片</p>
<p>🏷️  你可以对文章进行标签分组</p>
<p>📋  你可以自定义菜单，甚至可以创建外部链接菜单</p>
<p>💻  你可以在 <strong>𝖶𝗂𝗇𝖽𝗈𝗐𝗌</strong> 或 <strong>𝖬𝖺𝖼𝖮𝖲</strong> 设备上使用此客户端</p>
<p>🌎  你可以使用 <strong>𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌</strong> 或 <strong>Coding Pages</strong> 向世界展示，未来将支持更多平台</p>
<p>💬  你可以进行简单的配置，接入 <a href="https://github.com/gitalk/gitalk">Gitalk</a> 或 <a href="https://github.com/SukkaW/DisqusJS">DisqusJS</a> 评论系统</p>
<p>🇬🇧  你可以使用<strong>中文简体</strong>或<strong>英语</strong></p>
<p>🌁  你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力</p>
<p>🖥  你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步</p>
<p>🌱 当然 <strong>Gridea</strong> 还很年轻，有很多不足，但请相信，它会不停向前🏃</p>
<p>未来，它一定会成为你离不开的伙伴</p>
<p>尽情发挥你的才华吧！</p>
<p>😘 Enjoy~</p>
]]></content>
    </entry>
</feed>